# Конкретные баги и сценарии их эксплуатации

## 1. Race Condition: Потеря состояния диалога

### Код с багом
```go
// dialog.go, строка 630
func (d *Dialog) updateState(state DialogState) {
    oldState := d.state  // Race: чтение без блокировки
    d.state = state      // Race: запись без блокировки
}

// dialog.go, строка 270  
func (d *Dialog) State() DialogState {
    return d.state  // Race: чтение без блокировки
}
```

### Сценарий эксплуатации
```go
// Горутина 1: Обработчик входящего BYE
go func() {
    dialog.updateState(DialogStateTerminated)
}()

// Горутина 2: Проверка состояния для отправки re-INVITE
go func() {
    if dialog.State() == DialogStateEstablished {
        // Race: состояние может измениться между проверкой и действием
        dialog.ReInvite(ctx, opts) // Отправится после BYE!
    }
}()
```

**Последствия**: 
- Отправка SIP сообщений в неправильном состоянии
- Нарушение RFC 3261
- Сбои на удаленной стороне

## 2. Двойное закрытие каналов - паника

### Код с багом
```go
// dialog.go, строка 581
func (d *Dialog) Close() error {
    // ... 
    if d.responseChan != nil {
        close(d.responseChan)  // Может быть вызвано дважды
    }
}
```

### Эксплуатация
```go
// Атакующий может вызвать одновременно из разных мест:
go dialog.Close()  // Из обработчика таймаута
go dialog.Close()  // Из обработчика BYE

// Результат: panic: close of closed channel
```

## 3. Потеря REFER подписок

### Код с багом
```go
// refer.go, строка 504
d.mutex.Lock()
if d.referSubscriptions == nil {
    d.referSubscriptions = make(map[string]*ReferSubscription)
}
d.referSubscriptions[subscription.ID] = subscription
d.mutex.Unlock()
```

### Race сценарий
```go
// Горутина 1: SendRefer
go func() {
    d.mutex.Lock()
    if d.referSubscriptions == nil { // Проверка
        // Переключение контекста здесь!
        d.referSubscriptions = make(map[string]*ReferSubscription)
    }
    d.mutex.Unlock()
}()

// Горутина 2: Другой SendRefer  
go func() {
    d.mutex.Lock()
    if d.referSubscriptions == nil { // Тоже nil!
        d.referSubscriptions = make(map[string]*ReferSubscription) // Перезапишет!
    }
    d.mutex.Unlock()
}()
```

**Результат**: Первая карта с подписками будет потеряна.

## 4. Неконсистентное обновление ключа диалога

### Код с багом
```go
// dialog_internal.go, строка 132
if d.remoteTag == "" {
    if toTag := resp.To().Params["tag"]; toTag != "" {
        d.remoteTag = toTag      // Race
        d.key.RemoteTag = toTag  // Race
    }
}
```

### Эксплуатация
```go
// Одновременная обработка двух 180 Ringing с разными тегами
// Горутина 1: обрабатывает первый 180
d.remoteTag = "tag1"
// Переключение контекста!
// Горутина 2: обрабатывает второй 180  
d.remoteTag = "tag2"
d.key.RemoteTag = "tag2"
// Переключение обратно
d.key.RemoteTag = "tag1"

// Результат: d.remoteTag = "tag2", d.key.RemoteTag = "tag1"
// Диалог не найдется по ключу!
```

## 5. Утечка горутин через REFER

### Код с багом
```go
// refer.go, строка 359
go func() {
    ctx := context.Background()  // Нет таймаута!
    subscription.SendNotify(ctx, 100, "Trying")
}()
```

### DoS атака
```go
// Атакующий отправляет множество REFER запросов
for i := 0; i < 10000; i++ {
    // Каждый REFER создает горутину
    sendReferRequest(targetDialog)
}

// Если сеть медленная или недоступна, 10000 горутин зависнут навсегда
```

## 6. Паника из пользовательского колбэка

### Код с багом  
```go
// handlers.go, строка 121
if s.callbacks.OnIncomingDialog != nil {
    s.callbacks.OnIncomingDialog(dialog)  // Нет recover!
}
```

### Атака
```go
stack.OnIncomingDialog(func(d IDialog) {
    panic("user error")  // Убьет горутину сервера!
})

// Результат: SIP сервер перестанет принимать входящие
```

## 7. Deadlock через вложенные блокировки

### Потенциальный сценарий
```go
// Пользовательский код
stack.OnIncomingDialog(func(d IDialog) {
    // Получаем все диалоги (берет блокировку стека)
    dialogs := stack.GetAllDialogs()
    
    // Для каждого пытаемся что-то сделать
    for _, dlg := range dialogs {
        dlg.State() // Если добавить блокировку, может быть deadlock
    }
})
```

## 8. Неатомарное обновление routeSet

### Код с багом
```go
// dialog_internal.go, строка 168
d.routeSet = nil  // Race
recordRoutes := resp.GetHeaders("Record-Route")
// ... парсинг ...
d.routeSet = append(d.routeSet, routeUri)  // Race
```

### Эксплуатация
```go
// Одновременные re-INVITE могут привести к:
// 1. Потере маршрутов
// 2. Дублированию маршрутов  
// 3. Миксу маршрутов из разных ответов
```

## Рекомендации по исправлению

1. **Использовать atomic для простых типов**:
```go
type Dialog struct {
    state int32  // atomic.LoadInt32/StoreInt32
}
```

2. **Immutable структуры для сложных данных**:
```go
type DialogRouteSet struct {
    routes []sip.Uri
}
// Всегда создавать новую при изменении
```

3. **Каналы для последовательной обработки**:
```go
type Dialog struct {
    commands chan DialogCommand
}
```

4. **Обязательный recover в критических местах**:
```go
defer func() {
    if r := recover(); r != nil {
        log.Printf("Recovered from panic: %v", r)
        // Корректная обработка
    }
}()
```

5. **Контексты с таймаутами везде**:
```go
ctx, cancel := context.WithTimeout(parent, 5*time.Second)
defer cancel()
```