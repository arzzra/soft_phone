// Package tests provides integration tests for SIP dialog functionality
package tests

import (
	"context"
	"fmt"
	"net"
	"sync"
	"testing"
	"time"

	"github.com/arzzra/soft_phone/pkg/sip/core/types"
	"github.com/arzzra/soft_phone/pkg/sip/dialog"
	"github.com/arzzra/soft_phone/pkg/sip/dialog/integration/client"
	"github.com/arzzra/soft_phone/pkg/sip/transaction"
	"github.com/arzzra/soft_phone/pkg/sip/transport"
)

const (
	opensipsAddr = "localhost:5060"
	callAPIAddr  = "ws://localhost:5059/call-api"
	testTimeout  = 30 * time.Second
)

// TestEnvironment holds test infrastructure
type TestEnvironment struct {
	stack       dialog.IStack
	transport   transport.Manager
	callAPIClient *client.Client
	localAddr   string
}

// SetupTestEnvironment creates test environment
func SetupTestEnvironment(t *testing.T) (*TestEnvironment, func()) {
	// Create transport manager
	transportMgr := transport.NewManager()
	
	// Create UDP transport
	udpTransport, err := transport.NewUDPTransport("0.0.0.0:0")
	if err != nil {
		t.Fatalf("Failed to create UDP transport: %v", err)
	}
	
	transportMgr.AddTransport("udp", udpTransport)
	transportMgr.SetDefaultTransport("udp")

	// Get local address
	localAddr := udpTransport.LocalAddr().String()
	host, port, _ := net.SplitHostPort(localAddr)
	if host == "0.0.0.0" {
		host = "localhost"
	}
	localAddr = fmt.Sprintf("%s:%s", host, port)

	// Create transaction layer
	txLayer := transaction.NewLayer(transportMgr)
	if err := txLayer.Start(); err != nil {
		t.Fatalf("Failed to start transaction layer: %v", err)
	}

	// Create dialog stack
	stackConfig := dialog.StackConfig{
		UserAgent:   "TestSIPClient/1.0",
		LocalAddr:   localAddr,
		DisplayName: "Test Client",
	}

	stack := dialog.NewStack(txLayer, stackConfig)
	if err := stack.Start(); err != nil {
		t.Fatalf("Failed to start dialog stack: %v", err)
	}

	// Create call-api client
	callAPIClient := client.New(callAPIAddr)
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	
	if err := callAPIClient.Connect(ctx); err != nil {
		// Call-API might not be available, skip tests
		t.Skipf("Call-API not available: %v", err)
	}

	cleanup := func() {
		callAPIClient.Close()
		stack.Shutdown()
		txLayer.Stop()
		transportMgr.Shutdown()
	}

	return &TestEnvironment{
		stack:         stack,
		transport:     transportMgr,
		callAPIClient: callAPIClient,
		localAddr:     localAddr,
	}, cleanup
}

// TestBasicCall tests basic call establishment and teardown
func TestBasicCall(t *testing.T) {
	env, cleanup := SetupTestEnvironment(t)
	defer cleanup()

	ctx, cancel := context.WithTimeout(context.Background(), testTimeout)
	defer cancel()

	// Test data
	caller := fmt.Sprintf("sip:alice@%s", env.localAddr)
	callee := "sip:bob@" + opensipsAddr

	// Channel to receive incoming dialog
	incomingChan := make(chan dialog.IDialog, 1)
	env.stack.OnIncomingDialog(func(d dialog.IDialog) {
		select {
		case incomingChan <- d:
		default:
		}
	})

	// Start call via call-api
	callID, err := env.callAPIClient.CallStart(ctx, caller, callee)
	if err != nil {
		t.Fatalf("Failed to start call: %v", err)
	}
	t.Logf("Started call with ID: %s", callID)

	// Wait for incoming INVITE
	var incomingDialog dialog.IDialog
	select {
	case incomingDialog = <-incomingChan:
		t.Log("Received incoming INVITE")
	case <-ctx.Done():
		t.Fatal("Timeout waiting for incoming INVITE")
	}

	// Verify dialog state
	if incomingDialog.State() != dialog.DialogStateInit {
		t.Errorf("Expected dialog state Init, got %v", incomingDialog.State())
	}

	// Accept the call
	err = incomingDialog.Accept(ctx, &types.SDP{
		Version:     0,
		Origin:      "test 123 456 IN IP4 " + env.localAddr,
		SessionName: "Test Session",
		Connection:  "IN IP4 " + env.localAddr,
		Media: []types.MediaDescription{
			{
				Type:     "audio",
				Port:     10000,
				Protocol: "RTP/AVP",
				Formats:  []string{"0", "8", "101"},
			},
		},
	})
	if err != nil {
		t.Fatalf("Failed to accept call: %v", err)
	}

	// Wait for dialog to be established
	time.Sleep(2 * time.Second)

	if incomingDialog.State() != dialog.DialogStateEstablished {
		t.Errorf("Expected dialog state Established, got %v", incomingDialog.State())
	}

	// End the call
	err = env.callAPIClient.CallEnd(ctx, callID)
	if err != nil {
		t.Fatalf("Failed to end call: %v", err)
	}

	// Wait for BYE
	time.Sleep(2 * time.Second)

	if incomingDialog.State() != dialog.DialogStateTerminated {
		t.Errorf("Expected dialog state Terminated, got %v", incomingDialog.State())
	}
}

// TestCallReject tests call rejection
func TestCallReject(t *testing.T) {
	env, cleanup := SetupTestEnvironment(t)
	defer cleanup()

	ctx, cancel := context.WithTimeout(context.Background(), testTimeout)
	defer cancel()

	// Test data
	caller := fmt.Sprintf("sip:alice@%s", env.localAddr)
	callee := "sip:bob@" + opensipsAddr

	// Channel to receive incoming dialog
	incomingChan := make(chan dialog.IDialog, 1)
	env.stack.OnIncomingDialog(func(d dialog.IDialog) {
		select {
		case incomingChan <- d:
		default:
		}
	})

	// Start call via call-api
	callID, err := env.callAPIClient.CallStart(ctx, caller, callee)
	if err != nil {
		t.Fatalf("Failed to start call: %v", err)
	}
	t.Logf("Started call with ID: %s", callID)

	// Wait for incoming INVITE
	var incomingDialog dialog.IDialog
	select {
	case incomingDialog = <-incomingChan:
		t.Log("Received incoming INVITE")
	case <-ctx.Done():
		t.Fatal("Timeout waiting for incoming INVITE")
	}

	// Reject the call
	err = incomingDialog.Reject(ctx, 486, "Busy Here")
	if err != nil {
		t.Fatalf("Failed to reject call: %v", err)
	}

	// Wait for termination
	time.Sleep(2 * time.Second)

	if incomingDialog.State() != dialog.DialogStateTerminated {
		t.Errorf("Expected dialog state Terminated, got %v", incomingDialog.State())
	}
}

// TestConcurrentCalls tests multiple concurrent calls
func TestConcurrentCalls(t *testing.T) {
	env, cleanup := SetupTestEnvironment(t)
	defer cleanup()

	ctx, cancel := context.WithTimeout(context.Background(), testTimeout)
	defer cancel()

	numCalls := 3
	var wg sync.WaitGroup
	wg.Add(numCalls)

	// Channel to collect errors
	errChan := make(chan error, numCalls)

	// Channel to receive incoming dialogs
	incomingChan := make(chan dialog.IDialog, numCalls)
	env.stack.OnIncomingDialog(func(d dialog.IDialog) {
		select {
		case incomingChan <- d:
		default:
		}
	})

	// Start multiple calls concurrently
	for i := 0; i < numCalls; i++ {
		go func(idx int) {
			defer wg.Done()

			caller := fmt.Sprintf("sip:user%d@%s", idx, env.localAddr)
			callee := fmt.Sprintf("sip:100%d@%s", idx+1, opensipsAddr)

			callID, err := env.callAPIClient.CallStart(ctx, caller, callee)
			if err != nil {
				errChan <- fmt.Errorf("call %d: failed to start: %w", idx, err)
				return
			}

			t.Logf("Started call %d with ID: %s", idx, callID)

			// Wait a bit before ending
			time.Sleep(3 * time.Second)

			if err := env.callAPIClient.CallEnd(ctx, callID); err != nil {
				errChan <- fmt.Errorf("call %d: failed to end: %w", idx, err)
			}
		}(i)
	}

	// Handle incoming dialogs
	go func() {
		for i := 0; i < numCalls; i++ {
			select {
			case d := <-incomingChan:
				// Accept each incoming call
				go func(dialog dialog.IDialog) {
					err := dialog.Accept(ctx, &types.SDP{
						Version:     0,
						Origin:      "test 123 456 IN IP4 " + env.localAddr,
						SessionName: "Test Session",
						Connection:  "IN IP4 " + env.localAddr,
						Media: []types.MediaDescription{
							{
								Type:     "audio",
								Port:     10000 + uint16(i*2),
								Protocol: "RTP/AVP",
								Formats:  []string{"0", "8"},
							},
						},
					})
					if err != nil {
						errChan <- fmt.Errorf("failed to accept dialog: %w", err)
					}
				}(d)
			case <-ctx.Done():
				return
			}
		}
	}()

	// Wait for all calls to complete
	wg.Wait()
	close(errChan)

	// Check for errors
	for err := range errChan {
		t.Error(err)
	}
}

// TestDialogStateTransitions tests dialog state machine transitions
func TestDialogStateTransitions(t *testing.T) {
	env, cleanup := SetupTestEnvironment(t)
	defer cleanup()

	ctx, cancel := context.WithTimeout(context.Background(), testTimeout)
	defer cancel()

	// Test data
	caller := fmt.Sprintf("sip:alice@%s", env.localAddr)
	callee := "sip:bob@" + opensipsAddr

	// Track state changes
	stateChanges := make([]dialog.DialogState, 0)
	var stateMutex sync.Mutex

	// Channel to receive incoming dialog
	incomingChan := make(chan dialog.IDialog, 1)
	env.stack.OnIncomingDialog(func(d dialog.IDialog) {
		// Subscribe to state changes
		d.OnStateChange(func(oldState, newState dialog.DialogState) {
			stateMutex.Lock()
			stateChanges = append(stateChanges, newState)
			stateMutex.Unlock()
			t.Logf("State transition: %v -> %v", oldState, newState)
		})

		select {
		case incomingChan <- d:
		default:
		}
	})

	// Start call
	callID, err := env.callAPIClient.CallStart(ctx, caller, callee)
	if err != nil {
		t.Fatalf("Failed to start call: %v", err)
	}

	// Wait for incoming INVITE
	var incomingDialog dialog.IDialog
	select {
	case incomingDialog = <-incomingChan:
		t.Log("Received incoming INVITE")
	case <-ctx.Done():
		t.Fatal("Timeout waiting for incoming INVITE")
	}

	// Accept the call
	err = incomingDialog.Accept(ctx, &types.SDP{
		Version:     0,
		Origin:      "test 123 456 IN IP4 " + env.localAddr,
		SessionName: "Test Session",
		Connection:  "IN IP4 " + env.localAddr,
		Media: []types.MediaDescription{
			{
				Type:     "audio",
				Port:     10000,
				Protocol: "RTP/AVP",
				Formats:  []string{"0"},
			},
		},
	})
	if err != nil {
		t.Fatalf("Failed to accept call: %v", err)
	}

	// Wait for establishment
	time.Sleep(2 * time.Second)

	// End the call
	err = env.callAPIClient.CallEnd(ctx, callID)
	if err != nil {
		t.Fatalf("Failed to end call: %v", err)
	}

	// Wait for termination
	time.Sleep(2 * time.Second)

	// Verify state transitions
	stateMutex.Lock()
	defer stateMutex.Unlock()

	expectedStates := []dialog.DialogState{
		dialog.DialogStateTrying,
		dialog.DialogStateEstablished,
		dialog.DialogStateTerminating,
		dialog.DialogStateTerminated,
	}

	if len(stateChanges) < len(expectedStates) {
		t.Errorf("Expected at least %d state changes, got %d", len(expectedStates), len(stateChanges))
	}

	// Verify final state
	if incomingDialog.State() != dialog.DialogStateTerminated {
		t.Errorf("Expected final state Terminated, got %v", incomingDialog.State())
	}
}