package dialog_test

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/arzzra/soft_phone/pkg/sip/core/types"
	"github.com/arzzra/soft_phone/pkg/sip/dialog"
	"github.com/arzzra/soft_phone/pkg/sip/transport"
)

// ExampleStack demonstrates basic usage of SIP dialog stack
func ExampleStack() {
	// Create transport manager
	transportMgr := transport.NewTransportManager()
	
	// Create and start UDP transport
	udpTransport := transport.NewUDPTransport()
	if err := udpTransport.Listen("0.0.0.0:5060"); err != nil {
		log.Fatal(err)
	}
	transportMgr.RegisterTransport(udpTransport)
	
	// Create stack
	stack := dialog.NewStack(transportMgr, "192.168.1.100", 5060)
	
	// Set handler for incoming calls
	stack.OnIncomingDialog(func(d dialog.IDialog) {
		fmt.Printf("Incoming call from %s\n", d.RemoteTag())
		
		// Auto-answer with 200 OK
		if err := d.Accept(context.Background()); err != nil {
			fmt.Printf("Failed to accept call: %v\n", err)
			return
		}
		
		// Wait a bit then hangup
		time.Sleep(5 * time.Second)
		
		if err := d.Bye(context.Background(), "Normal clearing"); err != nil {
			fmt.Printf("Failed to send BYE: %v\n", err)
		}
	})
	
	// Start stack
	ctx := context.Background()
	if err := stack.Start(ctx); err != nil {
		log.Fatal(err)
	}
	defer stack.Shutdown(context.Background())
	
	// Make outgoing call
	target := types.NewSipURI("alice", "example.com")
	dialog, err := stack.NewInvite(ctx, target, func(req *types.Request) {
		// Add SDP body
		req.SetBody([]byte("v=0\r\no=- 123 456 IN IP4 192.168.1.100\r\n..."))
		req.SetHeader("Content-Type", "application/sdp")
	})
	
	if err != nil {
		log.Printf("Failed to create INVITE: %v", err)
		return
	}
	
	// Monitor dialog state changes
	dialog.OnStateChange(func(oldState, newState dialog.DialogState) {
		fmt.Printf("Dialog state changed from %s to: %s\n", oldState, newState)
	})
	
	// Output:
	// Dialog state changed to: Trying
}

// ExampleDialog_Refer demonstrates call transfer
func ExampleDialog_Refer() {
	// Assume we have an established dialog
	var dialog dialog.IDialog
	
	// Transfer call to another party
	transferTarget, _ := types.ParseURI("sip:bob@example.com")
	opts := dialog.ReferOpts{}
	err := dialog.Refer(context.Background(), transferTarget, opts)
	if err != nil {
		log.Printf("Failed to send REFER: %v", err)
		return
	}
	
	// Wait for REFER response
	subscription, err := dialog.WaitRefer(context.Background())
	if err != nil {
		log.Printf("REFER rejected: %v", err)
		return
	}
	
	// Monitor transfer progress
	go func() {
		for {
			select {
			case <-subscription.Done:
				fmt.Printf("Transfer completed\n")
				return
			case <-time.After(100 * time.Millisecond):
				// Check progress
				if subscription.Progress > 0 {
					fmt.Printf("Transfer progress: %d\n", subscription.Progress)
				}
			}
		}
	}()
}

// ExampleDialog_AttendedTransfer demonstrates attended transfer
func ExampleDialog_AttendedTransfer() {
	// Assume we have two established dialogs
	var dialogA, dialogB dialog.IDialog
	
	// Replace dialog A with dialog B (attended transfer)
	err := dialogA.ReferReplace(context.Background(), dialogB, dialog.ReferOpts{})
	if err != nil {
		log.Printf("Failed to send REFER with Replaces: %v", err)
		return
	}
	
	// Wait for transfer to complete
	subscription, err := dialogA.WaitRefer(context.Background())
	if err != nil {
		log.Printf("Attended transfer rejected: %v", err)
		return
	}
	
	// Monitor until completion
	<-subscription.Done
	fmt.Println("Attended transfer completed")
}