# Комплексный план разработки Dialog Layer и UASUAC

## 1. Анализ интерфейсов и требований

### 1.1 Основные компоненты системы

Из анализа `pkg/dialog/interfaces.go` и существующего плана выявлены следующие ключевые компоненты:

1. **UASUAC** - объединённый User Agent с функциями клиента и сервера
2. **IDialog** - основной интерфейс для управления SIP диалогами
3. **DialogState** - конечный автомат состояний диалога
4. **ReqOpts** - функциональные опции для настройки запросов
5. **Event handlers** - обработчики событий изменения состояния и получения тела сообщений

### 1.2 Ключевые требования

1. **Потокобезопасность** - все операции должны быть thread-safe
2. **Асинхронность** - неблокирующие операции с поддержкой контекстов
3. **Совместимость с sipgo** - использование низкоуровневых API без DialogUA/DialogClientCache
4. **Поддержка REFER** - реализация механизмов переадресации вызовов
5. **Управление состоянием** - строгий FSM для переходов состояний

### 1.3 Отличия от существующего плана

В интерфейсе `interfaces.go` есть следующие изменения по сравнению с планом:
- Используется `sipgo.Client`, `sipgo.Server`, `sipgo.UserAgent` напрямую в UASUAC
- `ReqOpts` определён как функциональная опция с сигнатурой `func(req *http.Request) error`
- Добавлен метод `SendRequest` для отправки произвольных запросов
- Добавлен метод `OnRequest` для обработки входящих запросов в рамках диалога

## 2. Технологические решения

### 2.1 Архитектурные решения

1. **Композиция вместо наследования**
   - UASUAC композирует sipgo.Client, sipgo.Server, sipgo.UserAgent
   - Это позволяет использовать все возможности sipgo без создания обёрток

2. **Конечный автомат (FSM)**
   - Использование паттерна State Machine для управления состояниями
   - Атомарные операции для изменения состояний
   - Валидация переходов согласно RFC 3261

3. **Управление памятью**
   - sync.Map для хранения диалогов (lock-free для чтения)
   - atomic.Value для часто читаемых полей
   - sync.RWMutex для защиты критических секций

4. **Асинхронная модель**
   - Каналы для доставки событий
   - Context для управления жизненным циклом
   - Горутины для неблокирующей обработки

### 2.2 Обоснование выбора технологий

1. **sync.Map vs обычная map + mutex**
   - sync.Map оптимизирована для сценариев с частым чтением
   - Подходит для кеша диалогов, где чтение происходит чаще записи

2. **atomic.Value для состояния**
   - Минимальные накладные расходы на чтение состояния
   - Гарантия атомарности без блокировок

3. **Функциональные опции (ReqOpts)**
   - Гибкая настройка запросов
   - Расширяемость без изменения API
   - Соответствие паттернам Go

## 3. Архитектура Dialog Layer

### 3.1 Структура компонентов

```
┌─────────────────────────────────────────────────────────┐
│                        UASUAC                           │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐    │
│  │sipgo.Client │  │sipgo.Server │  │sipgo.UserAgent│   │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘    │
│         │                 │                 │           │
│         └─────────────────┴─────────────────┘           │
│                           │                             │
│                    ┌──────▼──────┐                     │
│                    │DialogManager│                     │
│                    └──────┬──────┘                     │
└───────────────────────────┼─────────────────────────────┘
                           │
                    ┌──────▼──────┐
                    │   IDialog   │
                    └──────┬──────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
┌───────▼───────┐  ┌───────▼───────┐  ┌──────▼──────┐
│ State Machine │  │  Transaction  │  │   REFER     │
│     (FSM)     │  │   Manager     │  │  Manager    │
└───────────────┘  └───────────────┘  └─────────────┘
```

### 3.2 Слои архитектуры

1. **Transport Layer** (sipgo)
   - Обработка сетевых соединений
   - Парсинг SIP сообщений
   - Управление транзакциями

2. **Dialog Layer** (наша реализация)
   - Управление диалогами
   - Контроль состояний
   - Маршрутизация сообщений

3. **Application Layer**
   - Бизнес-логика приложения
   - Управление медиа-сессиями
   - UI/API интерфейсы

### 3.3 Потоки данных

```
Входящий запрос:
Network → sipgo.Server → DialogManager → Dialog → Application

Исходящий запрос:
Application → Dialog → sipgo.Client → Network

События:
Dialog State Change → Event Handler → Application
```

## 4. Дизайн конечного автомата (FSM)

### 4.1 Состояния диалога

```
┌─────────┐     INVITE      ┌─────────┐
│StateNone├────────────────►│StateEarly│
└─────────┘                 └────┬────┘
                                 │ 2xx + ACK
                                 ▼
                         ┌───────────────┐
                         │StateConfirmed │
                         └───────┬───────┘
                                 │ BYE
                                 ▼
                        ┌─────────────────┐
                        │StateTerminating │
                        └────────┬────────┘
                                 │ 200 OK (to BYE)
                                 ▼
                        ┌─────────────────┐
                        │StateTerminated  │
                        └─────────────────┘
```

### 4.2 Правила переходов

1. **StateNone → StateEarly**
   - Триггер: Получение/отправка INVITE
   - Условие: Валидный INVITE запрос
   - Действия: Создание диалога, установка Call-ID, tags

2. **StateEarly → StateConfirmed**
   - Триггер: 2xx ответ + ACK
   - Условие: Matching dialog ID
   - Действия: Обновление Route Set, Contact

3. **StateConfirmed → StateTerminating**
   - Триггер: BYE запрос
   - Условие: Диалог в состоянии Confirmed
   - Действия: Отправка/получение BYE

4. **StateTerminating → StateTerminated**
   - Триггер: 200 OK на BYE
   - Условие: BYE транзакция завершена
   - Действия: Очистка ресурсов, уведомление

### 4.3 Реализация FSM

```go
type stateMachine struct {
    current     atomic.Value // DialogState
    transitions map[stateTransition]transitionFunc
    mu          sync.RWMutex
}

type stateTransition struct {
    from DialogState
    to   DialogState
}

type transitionFunc func(ctx context.Context, trigger interface{}) error
```

## 5. План реализации

### Фаза 1: Базовая инфраструктура (3-4 дня)

#### 1.1 Создание основных типов и интерфейсов
- [ ] Реализация структуры UASUAC с композицией sipgo компонентов
- [ ] Создание базовой структуры Dialog с атомарными полями
- [ ] Реализация DialogManager с sync.Map хранилищем
- [ ] Определение вспомогательных типов (Body, ReqOpts)

#### 1.2 Реализация FSM
- [ ] Создание stateMachine с валидацией переходов
- [ ] Реализация атомарных операций изменения состояния
- [ ] Добавление системы уведомлений о смене состояний
- [ ] Тестирование всех возможных переходов

#### 1.3 Базовые операции с диалогами
- [ ] Реализация создания диалога (UAC/UAS роли)
- [ ] Добавление методов поиска диалогов
- [ ] Реализация удаления и очистки диалогов
- [ ] Создание системы генерации ID

### Фаза 2: Интеграция с sipgo (3-4 дня)

#### 2.1 Обработка SIP сообщений
- [ ] Интеграция с sipgo.Server для входящих запросов
- [ ] Интеграция с sipgo.Client для исходящих запросов
- [ ] Реализация маршрутизации сообщений к диалогам
- [ ] Обработка транзакций внутри диалогов

#### 2.2 Управление заголовками
- [ ] Обработка Route/Record-Route заголовков
- [ ] Управление Contact заголовками
- [ ] Автоматическое увеличение CSeq
- [ ] Валидация обязательных заголовков

#### 2.3 Реализация основных методов IDialog
- [ ] Answer() - ответ на входящий вызов
- [ ] Reject() - отклонение вызова
- [ ] Terminate() - завершение диалога
- [ ] SendRequest() - отправка произвольных запросов

### Фаза 3: REFER и переадресация (2-3 дня)

#### 3.1 Базовая поддержка REFER
- [ ] Реализация метода Refer()
- [ ] Создание Refer-To заголовков
- [ ] Обработка NOTIFY подписки
- [ ] Отслеживание прогресса REFER

#### 3.2 Attended Transfer (ReferReplace)
- [ ] Реализация метода ReferReplace()
- [ ] Создание Replaces заголовков
- [ ] Корреляция диалогов для замены
- [ ] Обработка early-only флага

### Фаза 4: Расширенные возможности (2-3 дня)

#### 4.1 Обработка событий
- [ ] Реализация OnRequest() для входящих запросов
- [ ] Система обработчиков событий (OnStateChange, OnBody)
- [ ] Асинхронная доставка событий через каналы
- [ ] Управление подписками на события

#### 4.2 Оптимизация и мониторинг
- [ ] Добавление метрик производительности
- [ ] Реализация health checks для диалогов
- [ ] Автоматическая очистка устаревших диалогов
- [ ] Логирование с использованием slog

### Фаза 5: Тестирование и документация (2-3 дня)

#### 5.1 Unit тесты
- [ ] Тесты для FSM и переходов состояний
- [ ] Тесты для thread-safety операций
- [ ] Тесты для интеграции с sipgo
- [ ] Тесты для REFER функциональности

#### 5.2 Интеграционные тесты
- [ ] Сценарии установления и завершения вызовов
- [ ] Тесты переадресации вызовов
- [ ] Тесты обработки ошибок
- [ ] Нагрузочные тесты

#### 5.3 Документация
- [ ] API документация с примерами
- [ ] Руководство по миграции
- [ ] Sequence диаграммы основных сценариев
- [ ] Troubleshooting guide

## 6. Технические детали реализации

### 6.1 Структура пакета

```
pkg/dialog/
├── interfaces.go          # Уже существует
├── uasuac.go             # Реализация UASUAC
├── dialog.go             # Реализация IDialog
├── manager.go            # DialogManager
├── state_machine.go      # FSM реализация
├── refer.go              # REFER функциональность
├── builder.go            # Builders для запросов
├── options.go            # ReqOpts и другие опции
├── errors.go             # Определение ошибок
├── utils.go              # Вспомогательные функции
└── tests/
    ├── dialog_test.go
    ├── fsm_test.go
    ├── refer_test.go
    └── integration_test.go
```

### 6.2 Примеры использования

```go
// Создание UASUAC
ua, _ := sipgo.NewUA()
client, _ := sipgo.NewClient(ua)
server, _ := sipgo.NewServer(ua)

uasuac := &UASUAC{
    Client: *client,
    Server: *server,
    UserAgent: *ua,
}

// Создание диалога (UAC)
dialog, err := manager.CreateDialogUAC(ctx, inviteRequest)

// Ответ на входящий вызов
err := dialog.Answer(Body{
    Content: []byte(sdp),
    ContentType: "application/sdp",
}, nil)

// Переадресация вызова
targetURI, _ := sip.ParseUri("sip:bob@example.com")
tx, err := dialog.Refer(ctx, targetURI)
```

### 6.3 Обработка ошибок

Все ошибки должны быть типизированы и проверяемы:

```go
var (
    ErrDialogNotFound = errors.New("dialog not found")
    ErrInvalidState   = errors.New("invalid dialog state")
    ErrTimeout        = errors.New("operation timeout")
)

// Использование
if errors.Is(err, ErrDialogNotFound) {
    // Обработка отсутствия диалога
}
```

## 7. Критерии успеха

1. **Функциональность**
   - ✓ Полная реализация интерфейса IDialog
   - ✓ Работающий REFER с attended transfer
   - ✓ Корректная обработка всех состояний

2. **Производительность**
   - ✓ Обработка 1000+ одновременных диалогов
   - ✓ Latency < 10ms для основных операций
   - ✓ Отсутствие утечек памяти

3. **Качество кода**
   - ✓ Покрытие тестами > 80%
   - ✓ Прохождение golangci-lint
   - ✓ Документация всех публичных методов

4. **Совместимость**
   - ✓ Работа с существующим кодом media/rtp
   - ✓ Совместимость с sipgo без модификаций
   - ✓ Соответствие RFC 3261

## 8. Риски и митигация

1. **Сложность интеграции с sipgo**
   - Риск: Недокументированное поведение sipgo
   - Митигация: Тщательное изучение исходников, создание изолирующего слоя

2. **Производительность FSM**
   - Риск: Блокировки при высокой нагрузке
   - Митигация: Использование lock-free структур, профилирование

3. **Совместимость с SIP устройствами**
   - Риск: Различия в реализации SIP
   - Митигация: Тестирование с разными SIP серверами/клиентами

## 9. Временная оценка

- Фаза 1: 3-4 дня
- Фаза 2: 3-4 дня  
- Фаза 3: 2-3 дня
- Фаза 4: 2-3 дня
- Фаза 5: 2-3 дня

**Итого: 12-17 дней**

## 10. Следующие шаги

1. Утверждение плана
2. Настройка окружения разработки
3. Начало реализации с Фазы 1
4. Ежедневные статус-апдейты
5. Code review после каждой фазы